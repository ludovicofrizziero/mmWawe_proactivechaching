%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%Simulate a mmWave scenario with proactive caching.
%
%Authors: Frizziero - Suman - Dell'Eva
%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear all;
close all;
clc;

seed = sum(clock);
rng(seed);

print_scenario = false;
addpath(genpath('fnc'))
addpath(genpath('utils'))
addpath(genpath('Classes'))

%% parameters for channel
f = 28e9; %carrier frequency [Hz]
c = 3e8; % light speed [m/s]
C_L = 10^(-7.2);
C_N = 10^(-6.14);
alpha_L = 2; % LOS PL exponent
alpha_N = 2.92; % NLOS PL exponent
P_tx = 27; % transmitting power [dBm]
P_tx_lin = 0.5;
BW = 1e9; % Bandwidth [Hz]
thermal_noise = 10^((-174+7)/10)*BW ; % thermal noise in linear scale (OBS: -30 to convert in dB)
sigma = thermal_noise/P_tx_lin; % thermal noise, normalized at the tranmitting power

%% number of antennas for BS and UE
n_tx = 64; %WARNING: all values must be perfect squares
n_rx = 16; %WARNING: all values must be perfect squares

%% paramers for road
v = 100/3.6; % speed [m/s]
road_length = 1000;
d_R = 2.5; 
W_L = 3.7; % lane width
N_0 = 3; % # of obstacle lanes per direction
R = d_R + N_0*W_L; % road width
BS_per_km = 10;

%% parameters for simulation
n_rep_PL = 4;
theta_out = -5; %SINR outage threshold [dB]
outage_thresh = 10^(theta_out/10); %SINR outage threshold
T_sim = floor(1000/v); % simulation duration [s]
dt = 0.1; %  simulation step [s]
T_tracking = 0.1; % tracking periodicity for BF vector [s]
T_mul_users_update = 1; %how often BSs change n of connected users 
t_H = 0.3; % udpate of channel instances
n_users = 25; % mean number of users per BS, poisson r.v.

DEBUG = n_rep_PL < 2;
SAVE_DATA_VERBOSE = true;

%% %%%%%%%%%%%%%%%%%%%%%%% Monte Carlo Method %%%%%%%%%%%%%%%%%%%%%%%%%%
rate_tmp = cell(n_rep_PL, 1);
tic; 
savings = cell(n_rep_PL, 1);
parfor iter = 1:n_rep_PL  
    
    fprintf('iteration: %d\n', iter);      
    
    start_ue_pos = [0, d_R + randi(3,1)*W_L - W_L/2, 0]; %(x,y,z) position of UE
    shared_data = BaseStation.sharedData;
    UE = UserEquipment(n_rx, f, start_ue_pos, v, T_tracking, T_sim/dt);
    shared_data.UE = UE;
    UE.sharedData = shared_data;
        
    n_BS_top = BS_per_km; % number of BSs
    n_BS_bottom = BS_per_km; % number of BSs   
    BS_distance_avg_top = 1000/n_BS_top;
    BS_distance_avg_bottom = 1000/n_BS_bottom;
    delta_top = ceil(BS_distance_avg_top/8);
    delta_bottom = ceil(BS_distance_avg_bottom/8);    
    
    allBS = cell(n_BS_top + n_BS_bottom, 1);
    for i = 1:n_BS_top
        pos = [(i-1)*BS_distance_avg_top+unifrnd(-delta_top , delta_top)+BS_distance_avg_top/2 , 2 * R, 8]; %top BS alternated wrt BS bottom
        allBS{i} = BaseStation(2*i, n_tx, f, BW, pos, t_H, T_tracking, n_users); 
    end
    
    for i = 1:n_BS_bottom
        pos = [(i-1)*BS_distance_avg_bottom+unifrnd(-delta_bottom , delta_bottom) , 0, 8];
        allBS{i + n_BS_top} = BaseStation(2*i-1, n_tx, f, BW, pos, t_H, T_tracking, n_users); 
    end        
    
    shared_data.servingBS = allBS{1}; %just for initialization
    UE.init();
    for i = 1:length(allBS)
            allBS{i}.init();
    end
    
    %% allocate file to BS
    [X, chunks] = solve_allocation_problem(allBS, UE, DEBUG);
    
    for i = 1:size(X)
        allBS{i}.allocate_memory_for_ue(chunks(i) * X(i));
    end
    
    if DEBUG
        disp(X');
    end
    %%
    
    %% for debug, plot BS disposition
    if DEBUG
        figure;
        hold on;
        for i = 1:n_BS_top+n_BS_bottom
            plot(allBS{i}.pos(1), allBS{i}.pos(2), '*')
            text(allBS{i}.pos(1), allBS{i}.pos(2)+1, int2str(allBS{i}.ID));
            if allBS{i}.memory > 0
                text(allBS{i}.pos(1), allBS{i}.pos(2)+3, num2str(double(allBS{i}.memory), '%1.3e'));
            end
        end
        hold off;
    end
    %%
    
    %% start simulation
    index_internal = 1;
    sim_steps = dt:dt:T_sim;
    rate = zeros(length(sim_steps), 1);
    servingBS_IDs = zeros(length(sim_steps), 1);
    for t = sim_steps 
        UE.update(t, dt);
        
        for i = 1:length(allBS)
            allBS{i}.update(t, dt);
        end
        
        %% for debug
        if DEBUG
            fprintf('-\n');
        end
        %%
     
        SINR_num = shared_data.servingBS.signal_power_at_ue; % numerator of SINR (depends on the beamwidth)
        
        SINR_interference = -SINR_num; % we don't want such signal_power_at_ue here, but in the for loop we sum it for "error"
        for i = 1:length(allBS)
            SINR_interference = SINR_interference + (allBS{i}.signal_power_at_ue);    
        end       
        SINR_interference = SINR_interference * 0.5; % ??? why is it divided by 2 ???
                
        SINR_den = SINR_interference + thermal_noise/shared_data.servingBS.n; %we must account for the avaiable bandwith to the UE, not the total BW

        SINR = SINR_num / SINR_den; 
        if SINR < outage_thresh
            SINR = 0; %outage -> no connection between BS and UE
        end       
        
        %% file transmission
        %consider rate for the n-users loaded BS
        r = shared_data.servingBS.BW * log2(1+SINR) / shared_data.servingBS.n;   %OUTPUT of this Monte Carlo iteration        
        
        f_chunk = shared_data.servingBS.download_file(dt, r);
        UE.receive_file_chunk(f_chunk);
        %%
        
        rate(index_internal) = r;
        servingBS_IDs(index_internal) = shared_data.servingBS.ID;
        index_internal = index_internal + 1; 
    end   

    if DEBUG
        for i = 1:max(size(allBS))
            fprintf('BS %d: %1.3e bits remaining\n', allBS{i}.ID, double(allBS{i}.memory));
        end
        
        fprintf('UE buffer load: %1.3e %% \n', double(UE.buffer)/double(UE.max_buffer));
    end
    
    if SAVE_DATA_VERBOSE
        [ue_buffer, ue_max_buffer, ue_lost_data, ue_waiting_time] = UE.dump_data();
        BSs_pos = zeros(max(size(allBS)), 3);
        BSs_mem_state = zeros(max(size(allBS)), 1);
        for i = 1:max(size(allBS))
            fprintf('BS %d: %1.3e bits remaining\n', allBS{i}.ID, double(allBS{i}.memory));
            BSs_pos(i, :) = allBS{i}.pos;
            BSs_mem_state(i) = allBS{i}.memory;
        end        
        
        s = struct;
        s.ue_buffer = ue_buffer;
        s.ue_max_buffer = ue_max_buffer;
        s.ue_lost_data = ue_lost_data;
        s.ue_waiting_time = ue_waiting_time;
        s.ue_requested_rate = UE.requested_rate;
        s.rate = rate;
        s.servingBS_IDs = servingBS_IDs;
        s.BSs_pos = BSs_pos;
        s.BSs_mem_state = BSs_mem_state;
        s.X = X;
        s.chunks = chunks;        
        
        savings{iter} = s;
    end
    
    rate_tmp{iter} = [min(rate), mean(rate), max(rate), std(rate)]; % entire OUTPUT of the Monte Carlo method
end

stop_timer = toc; 
fprintf('runtime: %4.3f s\n', stop_timer);  

%% %%%%%%%%%%%%%%%%%%%%%%reorder output%%%%%%%%%%%%%%%%%%%%%%
min_rate_final = zeros(1,n_rep_PL);
mean_rate_final = zeros(1,n_rep_PL); 
max_rate_final = zeros(1,n_rep_PL);
std_rate_final = zeros(1,n_rep_PL);

for iter =  1:n_rep_PL 
    min_rate_final(1, iter) = rate_tmp{iter}(1);
    mean_rate_final(1, iter) = rate_tmp{iter}(2);
    max_rate_final(1, iter) = rate_tmp{iter}(3);
    std_rate_final(1, iter) = rate_tmp{iter}(4);
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

formatSpec = '%4d->\tmin\t%2.6f\tmean\t%2.6f\tmax\t%2.6f\tstd\t%2.6f\tGbps\n';  %tab separeted values
tmp = 1:n_rep_PL;
iter_vec = 1:n_rep_PL;

tofile =    [   iter_vec;    ...
                min_rate_final / 1e9;  ...
                mean_rate_final / 1e9;  ...
                max_rate_final / 1e9;  ...
                std_rate_final / 1e9   ...
            ];

fname = sprintf('RESULTS\\rate_%d_%d_%d.txt', BS_per_km, n_tx, n_rx);
fileID = fopen(fname,'w');
fprintf(fileID, 'configuration:\t%d BSperKm\t%d n_tx\t%d n_rx\n', [BS_per_km, n_tx, n_rx]);
fprintf(fileID, formatSpec, tofile);
fclose(fileID);

name = strcat('RESULTS//savings.mat');
save(   name, 'savings' );

%print a fast report of the simulation
fprintf('mean rate: %2.6f Gbps\n', mean(mean_rate_final(1, :)) / 1e9);